<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="paper-datatable-api-shared-styles.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../app-localize-behavior/app-localize-behavior.html">
<link rel="import"href="../vaadin-date-picker/vaadin-date-picker-light.html">

<!--

`paper-datatable-api` is a material design implementation of a data table.

    <iron-ajax auto url="data.json" last-response="{{data}}"></iron-ajax>

    <paper-datatable-api data="[[data]]">
      <paper-datatable-api-column header="Fruit" property="fruit">
        <template>
          <span>{{value}}</span>
        </template>
      </paper-datatable-api-column>
      <paper-datatable-api-column header="Color" property="color">
        <template>
          <span>{{value}}</span>
        </template>
      </paper-datatable-api-column>
    </paper-datatable-api>

### Features

- [Follows the guideline of Material Design](https://material.google.com/components/data-tables.html#)
- Hide/Show columns
- Choose which columns can be hidden or show
- Sort
- Pagination
- Checkboxes to select or manipulate data
- Keep the selected data throught the pages
- Filter a column
- Ability to filter columns

### Styling

The following custom properties and mixins are available for styling:

Custom property                                   | Description                                  | Default
--------------------------------------------------|----------------------------------------------|---------------
`--paper-datatable-api-checked-checkbox-color`    | Define color of checked checkbox             | `--primary-color`
`--paper-datatable-api-unchecked-checkbox-color`  | Define color of unchecked checkbox           | `--primary-color`
`--paper-datatable-api-tr-selected-background`    | Define color of the selected tr              | `--paper-grey-100`
`--paper-datatable-api-header`                    | Mixin applied to the columns header          | `{}`
`--paper-datatable-api-tr-hover-background-color` | Define color of the tr background hover      | `none`
`--paper-datatable-api-header-sorted`             | Mixin applied to the sorted columns header   | `{}`

@element paper-datatable-api
@demo demo/index.html
-->
<dom-module id="paper-datatable-api">
  <template>
    <style>
      .paper-datatable-api-col-1 {
        display: none;
      }
    </style>
    <style include="paper-datatable-api-shared-styles"></style>
    <style include="iron-flex iron-flex-alignment"></style>

    <div id="wrapper" class$="[[_generateClass(filters, paginate)]]">
      <table>
        <thead class$="[[_generateClass(filters)]]">
          <tr>
            <template is="dom-if" if="[[selectable]]" restamp>
              <th class="selectable">
                <div>
                  <template is="dom-if" if="[[allowTheSelectionOfAllTheElements]]" restamp>
                    <paper-checkbox on-change="_selectAllCheckbox"></paper-checkbox>
                  </template>
                </div>
              </th>
            </template>
            <template is="dom-repeat" items="[[_columns]]" as="column">
              <th class$="[[_generateClass(filters)]] pgTh" data-column="[[column]]" sort-direction$="[[column.sortDirection]]" sorted$="[[column.sorted]]" sortable$="[[column.sortable]]">

                <div class="layout horizontal center">

                  <template is="dom-if" if="[[equals(positionSortIcon, 'right')]]">
                    <template is="dom-if" if="[[column.activeFilter]]" on-dom-change="_handleActiveFilterChange">
                      <template is="dom-if" if="[[!column.date]]" restamp>
                        <paper-input class="flex" no-label-float placeholder="[[column.header]]" data-column="[[column]]" on-keydown="_handleKeyDownInput" on-blur="_handlePaperInputChange"></paper-input>
                      </template>
                      <template is="dom-if" if="[[column.date]]" restamp>
                        <vaadin-date-picker-light attr-for-value="value">
                          <paper-input class="flex" no-label-float placeholder="[[column.header]]" data-column="[[column]]" on-blur="_handleVaadinDatePickerLight"></paper-input>
                        </vaadin-date-picker-light>
                      </template>
                    </template>
                    <template is="dom-if" if="[[!column.activeFilter]]">
                      <div class="flex">
                        [[column.header]]
                      </div>
                    </template>
                    <paper-icon-button icon="arrow-downward" class="sort" on-tap="_handleSort" data-column="[[column]]"></paper-icon-button>
                    <template is="dom-if" if="[[column.filter]]">
                      <template is="dom-if" if="[[column.activeFilter]]">
                        <paper-icon-button icon="sort" class="filter active" data-column="[[column]]" on-tap="_handleFilter"></paper-icon-button>
                      </template>
                      <template is="dom-if" if="[[!column.activeFilter]]">
                        <paper-icon-button icon="sort" class="filter" data-column="[[column]]" on-tap="_handleFilter"></paper-icon-button>
                      </template>
                    </template>
                  </template>

                  <template is="dom-if" if="[[equals(positionSortIcon, 'left')]]">
                    <paper-icon-button icon="arrow-downward" class="sort" on-tap="_handleSort" data-column="[[column]]"></paper-icon-button>
                    <template is="dom-if" if="[[column.filter]]">
                      <template is="dom-if" if="[[column.activeFilter]]">
                        <paper-icon-button icon="sort" class="filter active" data-column="[[column]]" on-tap="_handleFilter"></paper-icon-button>
                      </template>
                      <template is="dom-if" if="[[!column.activeFilter]]">
                        <paper-icon-button icon="sort" class="filter" data-column="[[column]]" on-tap="_handleFilter"></paper-icon-button>
                      </template>
                    </template>
                    <template is="dom-if" if="[[column.activeFilter]]" on-dom-change="_handleActiveFilterChange">
                      <template is="dom-if" if="[[!column.date]]" restamp>
                        <paper-input class="flex" no-label-float placeholder="[[column.header]]" data-column="[[column]]" on-keydown="_handleKeyDownInput" on-blur="_handlePaperInputChange"></paper-input>
                      </template>
                      <template is="dom-if" if="[[column.date]]" restamp>
                        <vaadin-date-picker-light attr-for-value="value">
                          <paper-input class="flex" no-label-float placeholder="[[column.header]]" data-column="[[column]]" on-blur="_handleVaadinDatePickerLight"></paper-input>
                        </vaadin-date-picker-light>
                      </template>
                    </template>
                    <template is="dom-if" if="[[!column.activeFilter]]">
                      <div class="flex">
                        [[column.header]]
                      </div>
                    </template>
                  </template>

                </div>
              </th>
            </template>
          </tr>
        </thead>
        <tbody class$="[[_generateClass(filters)]]">
        </tbody>
        <template is="dom-if" if="[[paginate]]" restamp>
          <tfoot class$="[[_generateClass(filters, paginate)]]">
            <tr>
              <td colspan$="[[_columnsHeight]]">
                <div>
                  <div class="layout horizontal end-justified center">
                    <div class="layout horizontal center">
                      <div>
                        [[localize('rowPerPage')]]:
                      </div>
                      <div class="size">
                        <paper-dropdown-menu no-label-float vertical-align="bottom">
                          <paper-listbox attr-for-selected="size" on-iron-select="_newSizeIsSelected" selected="[[size]]" class="dropdown-content">
                            <template is="dom-repeat" items="[[availableSize]]" as="size">
                              <paper-item size="[[size]]">[[size]]</paper-item>
                            </template>
                          </paper-listbox>
                        </paper-dropdown-menu>
                      </div>
                    </div>
                    <div class="status">
                      [[_computeCurrentSize(page, size)]]-[[_computeCurrentMaxSize(page, size)]] [[localize('of')]] [[totalElements]]
                    </div>
                    <template is="dom-if" if="[[!_prevButtonEnabled(page)]]">
                      <paper-icon-button icon="chevron-left" disabled on-tap="_prevPage"></paper-icon-button>
                    </template>
                    <template is="dom-if" if="[[_prevButtonEnabled(page)]]">
                      <paper-icon-button icon="chevron-left" on-tap="_prevPage"></paper-icon-button>
                    </template>
                    <template is="dom-if" if="[[!_nextButtonEnabled(page, totalPages)]]">
                      <paper-icon-button icon="chevron-right" disabled on-tap="_nextPage"></paper-icon-button>
                    </template>
                    <template is="dom-if" if="[[_nextButtonEnabled(page, totalPages)]]">
                      <paper-icon-button icon="chevron-right" on-tap="_nextPage"></paper-icon-button>
                    </template>
                  </div>
                </div>
              </td>
            </tr>
          </tfoot>
        </template>
      </table>
    </div>
  </template>

  <script>
    Polymer({

      is: 'paper-datatable-api',

      properties: {
        /**
         * The columns element.
         */
        _columns: {
          type: Array,
          value: [],
        },
        /**
         * The list of hideable columns.
         * It is exposed to create a list of label (see demo/advance-demo.html).
         */
        toggleColumns: {
          type: Array,
          notify: true,
          value: [],
        },
        /**
         * Contains the data which will be displayed in the table.
         */
        data: {
          type: Array,
          observer: '_dataChanged',
        },
        /**
         * If true, the pagination will be activated.
         */
        paginate: {
          type: Boolean,
          value: false,
        },
        /**
         * The current page.
         */
        page: {
          type: Number,
          notify: true,
        },
        /**
         * The current size.
         */
        size: {
          type: Number,
          notify: true,
        },
        /**
         * If true, a filter on each column is added.
         */
        filters: {
          type: Boolean,
          value: false,
        },
        /**
         * The total of elements have to be provided in case of pagination, it is mandatory.
         */
        totalElements: Number,
        /**
         * The total of pages have to be provided in case of pagination, it is mandatory.
         * It is used to compute the footer.
         */
        totalPages: Number,
        /**
         * The available size in case of pagination.
         */
        availableSize: {
          type: Array,
          value: [10],
        },
        /**
         * If true, the rows may be selectable.
         */
        selectable: {
          type: Boolean,
          value: false,
        },
        /**
         * If false, the paper-checkbox in the header which allow to select all rows is hidden.
         */
        allowTheSelectionOfAllTheElements: {
          type: Boolean,
          value: true,
        },
        /**
         * Contains the positions of selected columns.
         * Can contain a specific data if selectableDataKey is setted.
         */
        selectedRows: {
          type: Array,
          value: [],
        },
        /**
         * If it is setted, the selected rows are persistant (throught the pages).
         * Uses the value of the rowData following the defined key.
         */
        selectableDataKey: {
          type: String,
        },
        /**
         * Change the position of the sort icon in the header.
         */
        positionSortIcon: {
          type: String,
          value: 'left',
        },
        language: {
          type: String,
          value: 'en',
        },
        /**
         * If it is setted, the date picker is localized with this object.
         * See https://vaadin.com/docs/-/part/elements/vaadin-date-picker/vaadin-date-picker-localization.html.
         */
        localeDatePicker: {
          type: Object,
        },
        resources: {
          value: function () {
            return {
              en: {
                rowPerPage: 'Row per page',
                of: 'of',
              },
              'en-en': {
                rowPerPage: 'Row per page',
                of: 'of',
              },
              'en-US': {
                rowPerPage: 'Row per page',
                of: 'of',
              },
              fr: {
                rowPerPage: 'Ligne par page ',
                of: 'sur',
              },
              'fr-fr': {
                rowPerPage: 'Ligne par page ',
                of: 'sur',
              },
            };
          },
        },
      },

      behaviors: [
        Polymer.AppLocalizeBehavior,
      ],

      attached: function () {
        this._setColumns();
        var userLang = navigator.language || navigator.userLanguage;
        this.language = userLang;
      },

      equals: function (targetedValue, value) {
        return value === targetedValue;
      },

      _generateClass: function (filters, paginate) {
        if (filters && paginate) {
          return 'paginate filters';
        }

        if (filters) {
          return 'filters';
        }

        if (paginate) {
          return 'paginate';
        }
      },

      _nextPage: function () {
        if ((this.page + 1) < this.totalPages) {
          this.page = this.page + 1;
        }
      },

      _prevPage: function () {
        if (this.page > 0) {
          this.page = this.page - 1;
        }
      },

      _nextButtonEnabled: function (page, totalPages) {
        return (page + 1) < totalPages;
      },

      _prevButtonEnabled: function (page) {
        return page > 0;
      },

      _computeCurrentSize: function (page, size) {
        return (page * size) + 1;
      },

      _computeCurrentMaxSize: function (page, size) {
        var maxSize = size * (page + 1);
        return (maxSize > this.totalElements ? this.totalElements : maxSize);
      },

      _dataChanged: function (data) {
        this._removeRows();
        this._fillRows(data);
        this._fillColumns();
      },

      _removeRows: function () {
        var pgTrs = Polymer.dom(this.root).querySelectorAll('.paper-datatable-api-tr');
        pgTrs.forEach(function (pgTr) {
          Polymer.dom(this.$$('tbody')).removeChild(pgTr);
        }, this);
      },

      _fillRows: function (data) {
        data.forEach(function (rowData) {
          var trLocal = document.createElement('tr');
          trLocal.rowData = rowData;
          trLocal.className = 'paper-datatable-api-tr';

          Polymer.dom(this.$$('tbody')).appendChild(trLocal);
        }, this);
      },

      _fillColumns: function () {
        var pgTrs = Polymer.dom(this.root).querySelectorAll('.paper-datatable-api-tr');

        pgTrs.forEach(function (pgTr, i) {

          var rowData = pgTr.rowData;

          if (this.selectable) {
            var tdSelectable = document.createElement('td');
            tdSelectable.className = 'selectable';
            var paperCheckbox = document.createElement('paper-checkbox');
            this.listen(paperCheckbox, 'change', '_selectChange');
            paperCheckbox.rowData = rowData;
            paperCheckbox.rowIndex = i;

            if (this.selectableDataKey !== undefined &&
            rowData[this.selectableDataKey] !== undefined &&
            this.selectedRows.indexOf(rowData[this.selectableDataKey]) !== -1) {
              paperCheckbox.checked = true;
            }

            Polymer.dom(tdSelectable).appendChild(paperCheckbox);
            Polymer.dom(pgTr).appendChild(tdSelectable);
            Polymer.dom.flush();
          }

          this._columns.forEach(function (paperDatatableApiColumn) {

            var valueFromRowData = this._extractData(rowData, paperDatatableApiColumn.property);

            var isHidden = false;

            if (this.toggleColumns[paperDatatableApiColumn.position] &&
              !this.toggleColumns[paperDatatableApiColumn.position].show) {
              isHidden = true;
            }

            var otherPropertiesValue = {};
            paperDatatableApiColumn.otherProperties.forEach(function (property) {
              otherPropertiesValue[property] = this._extractData(rowData, property);
            }, this);

            var tdLocal = document.createElement('td');
            var template = paperDatatableApiColumn.fillTemplate(
              valueFromRowData,
              otherPropertiesValue
            );

            if (isHidden) {
              tdLocal.style.display = 'none';
            }

            Polymer.dom(tdLocal).appendChild(template.root);
            Polymer.dom(pgTr).appendChild(tdLocal);

          }, this);
        }, this);
      },

      _selectAllCheckbox: function (event) {
        var localTarget = Polymer.dom(event).localTarget;
        var allPaperCheckbox = Polymer.dom(this.root)
          .querySelectorAll('tbody tr td paper-checkbox');
        allPaperCheckbox.forEach(function (paperCheckbox) {
          if (localTarget.checked) {
            paperCheckbox.checked = true;
          } else {
            paperCheckbox.checked = false;
          }

          this._selectChange(paperCheckbox);
        }, this);
      },

      _selectChange: function (event) {
        var localTarget;
        if (event.type && event.type === 'change') {
          localTarget = Polymer.dom(event).localTarget;
        } else {
          localTarget = event;
        }

        var tr = Polymer.dom(localTarget).parentNode.parentNode;

        var rowData = localTarget.rowData;

        var rowId = localTarget.rowIndex;
        if (this.selectableDataKey !== undefined && rowData[this.selectableDataKey] !== undefined) {
          rowId = rowData[this.selectableDataKey];
        }

        var eventData = {};
        if (localTarget.checked) {
          this.push('selectedRows', rowId);
          eventData = {
            selected: [rowId],
            data: rowData,
          };
          tr.classList.add('selected');
        } else {
          this.splice('selectedRows', this.selectedRows.indexOf(rowId), 1);
          eventData = {
            deselected: [rowId],
            data: rowData,
          };
          tr.classList.remove('selected');
        }
        /**
         * Fired when a row is selected.
         * @event selection-changed
         * Event param: {{node: Object}} detail Contains selected id and row data.
         */
        this.fire('selection-changed', eventData);
      },

      _extractData: function (rowData, columnProperty) {
        if (columnProperty) {
          var splittedProperties = columnProperty.split('.');
          if (splittedProperties.length > 1) {
            return splittedProperties.reduce(function (prevRow, property) {
              if (typeof prevRow === 'string') {
                return rowData[prevRow][property];
              } else {
                return prevRow[property];
              }
            });
          } else {
            return rowData[columnProperty];
          }
        } else {
          return null;
        }
      },

      _setColumns: function () {
        this._columns = this.queryAllEffectiveChildren('paper-datatable-api-column')
          .map(function (column, i) {
            column.position = i;
            return column;
          });

        this.toggleColumns = this._columns.filter(function (column) {
          return column.hideable;
        });

        this._columnsHeight = this.selectable ? this._columns.length + 1 : this._columns.length;
      },

      /**
       * Hide or show a column following the number in argument.
       *
       * @property toggleColumn
       * @param {Number} columnPosition The number of column which will be toggled.
       */
      toggleColumn: function (columnPosition) {
        var column = this._columns[columnPosition];
        if (column && column.hideable) {
          var isShow = column.show;
          var indexColumn = this.selectable ? columnPosition + 2 : columnPosition + 1;
          var cssQuery = 'tr th:nth-of-type(' + indexColumn +
          '), tr td:nth-of-type(' + indexColumn + ')';
          Polymer.dom(this.root).querySelectorAll(cssQuery).forEach(function (tdTh) {
            var displayMode = isShow ? 'none' : 'table-cell';
            tdTh.style.display = displayMode;
          }, this);

          column.show = !isShow;
          var toggleColumnIndex = this.toggleColumns.findIndex(function (toggleColumn) {
            return toggleColumn.position === columnPosition;
          });

          this.set('toggleColumns.' + toggleColumnIndex + '.show', isShow ? false : true);
        }
      },

      _newSizeIsSelected: function () {
        var newSize = this.$$('paper-listbox').selected;
        if (newSize) {
          this.page = 0;
          this.size = newSize;
        }
      },

      _handleSort: function (event) {
        var column = event.model.column;
        var paperIconButton = event.currentTarget;
        var th = paperIconButton.parentNode.parentNode;

        var queryPaperIconButton = 'thead th[sortable][sorted] paper-icon-button.sort';
        Polymer.dom(this.root).querySelectorAll(queryPaperIconButton)
          .forEach(function (paperIconButton) {
            var thSorted = paperIconButton.parentNode.parentNode;

            if (thSorted.dataColumn !== column) {
              thSorted.removeAttribute('sort-direction');
              thSorted.removeAttribute('sorted');
              thSorted.dataColumn.set('sortDirection', sortDirection);
              thSorted.dataColumn.set('sorted', true);
            }
          });

        if (column.sortable) {
          var sortDirection = column.sortDirection === 'asc' ? 'desc' : 'asc';
          th.setAttribute('sort-direction', sortDirection);
          th.setAttribute('sorted', true);
          column.set('sortDirection', sortDirection);
          column.set('sorted', true);

          /**
           * Fired when a column is sorted.
           * @event sort
           * Event param: {{node: Object}} detail Contains sort object.
           * { sort: { property: STRING, direction: asc|desc }, column: OBJECT }
           */
          this.fire('sort', {
            sort: {
              property: column.property,
              direction: column.sortDirection,
            },
            column: column,
          });
        }
      },

      _handleActiveFilterChange: function(event) {
        var parentDiv = event.currentTarget.parentNode;
        this.async(() => {
          var paperInput = parentDiv.querySelector(':scope > paper-input');
          if (paperInput) {
            paperInput.focus();
          } else {
            var datePicker = parentDiv.querySelector('vaadin-date-picker-light');
            if (datePicker) {
              paperInput = datePicker.querySelector('paper-input');
              datePicker.i18n = this.localeDatePicker;
            }
          }
        });
      },

      _handlePaperInputChange: function(event) {
        var column = event.model.column;
        var input = event.currentTarget;

        this.async(() => {
          if (input.value !== '') {
            this._launchFilterEvent(input, column);
          } else if (!input.focused) {
            this._toggleFilter(column);
          }
        });
      },

      _handleVaadinDatePickerLight: function(event) {
        var column = event.model.column;
        var input = event.currentTarget;

        this.async(() => {
          if (input.value !== '') {
            this._launchFilterEvent(input, column);
          }
        });
      },

      _toggleFilter: function(column) {
        var columnIndex = this._columns.findIndex(function(_column) {
          return _column.property === column.property;
        });

        if (column.activeFilter) {
          this.set('_columns.' + columnIndex + '.activeFilter', false);
        } else {
          this.set('_columns.' + columnIndex + '.activeFilter', true);
        }
      },

      _launchFilterEvent: function(input, column) {
        /**
         * Fired when a filters inputs changed.
         * @event filter
         * Event param: {{node: Object}} detail Contains sort object.
         * { filter: { property: STRING, value: STRING }, column: OBJECT }
         */
        this.fire('filter', {
          filter: {
            property: column.property,
            value: input.value,
          },
          column: column,
        });
      },

      _handleFilter: function (event) {
        var paperIconButton = event.currentTarget;
        var column = event.model.column;

        if (column.activeFilter) {
          var input = paperIconButton.parentNode.querySelector('paper-input');
          input.value = '';
          this._launchFilterEvent(input, column);
        }
        this._toggleFilter(column);
      },

      _handleKeyDownInput: function (event) {
        if (event.keyCode === 13) {
          var column = event.model.column;
          var input = event.currentTarget;
          this._launchFilterEvent(input, column);
        }
      },
    });
  </script>
</dom-module>
